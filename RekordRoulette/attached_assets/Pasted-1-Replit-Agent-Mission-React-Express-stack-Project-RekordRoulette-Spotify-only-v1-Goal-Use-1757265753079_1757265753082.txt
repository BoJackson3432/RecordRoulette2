1) Replit Agent Mission (React + Express stack)

Project: RekordRoulette (Spotify-only v1)
Goal: Users sign in with Spotify, spin a vinyl/roulette wheel, get a random album from their saved library (deduped last 30 days), mark as listened to build streaks, and generate a shareable PNG with the album in a roulette frame. Deep-link to Spotify for playback.
Stack (Replit-friendly):

Frontend: React + TypeScript + Vite, Tailwind, Framer Motion

Backend: Express.js + TypeScript, Prisma ORM

DB: Postgres (Supabase/Neon)

Auth: Spotify Authorization Code flow (express-session), token refresh

Images: satori + @resvg/resvg-js (server-rendered PNG)

State: React Query (client)

Deployment: Replit Deployments

Core features:

Spotify OAuth, secure token storage (access + refresh)

POST /api/spin → returns a random album from user’s saved albums, avoiding repeats < 30 days

POST /api/listened → applies streak logic (daily increment/reset, track longest)

POST /api/share → returns 1080×1920 PNG (album cover in roulette/vinyl frame + caption)

GET /api/spins/:id → spin details for reveal view

GET /api/catalog?genre=&era= → Explore Mode (Spotify search filter by genre/decade)

React UI: Landing (spin), Spinner animation, Reveal view, Profile (streak, history), Share preview

Acceptance:

I can sign in via Spotify, press Spin, see an album from my saved library, open it in Spotify, mark listened and see streaks update, and generate a shareable PNG.

No secrets logged; error handling returns friendly JSON.

2) Project structure
rekord-roulette/
├─ server/                      # Express API (TypeScript)
│  ├─ src/
│  │  ├─ index.ts               # app bootstrap
│  │  ├─ auth/
│  │  │  ├─ spotify.ts          # OAuth handlers (login/callback/refresh)
│  │  │  └─ session.ts          # express-session config
│  │  ├─ lib/
│  │  │  ├─ prisma.ts
│  │  │  ├─ random.ts           # RNG + dedupe helpers
│  │  │  └─ share.ts            # satori/resvg image render
│  │  ├─ routes/
│  │  │  ├─ spin.ts             # POST /api/spin
│  │  │  ├─ spins.ts            # GET /api/spins/:id
│  │  │  ├─ listened.ts         # POST /api/listened
│  │  │  ├─ share.ts            # POST /api/share
│  │  │  └─ catalog.ts          # GET /api/catalog
│  │  └─ types.d.ts
│  └─ prisma/
│     └─ schema.prisma
├─ web/                         # React (Vite + TS)
│  ├─ src/
│  │  ├─ main.tsx
│  │  ├─ App.tsx
│  │  ├─ api/client.ts          # React Query + fetch base
│  │  ├─ pages/
│  │  │  ├─ Landing.tsx
│  │  │  ├─ SpinReveal.tsx
│  │  │  └─ Profile.tsx
│  │  ├─ components/
│  │  │  ├─ Spinner.tsx
│  │  │  ├─ AlbumCard.tsx
│  │  │  └─ StreakBadge.tsx
│  │  └─ styles.css
│  └─ index.html
├─ package.json                 # workspaces: ["server","web"]
├─ .env.example
└─ README.md

3) Commands (top-level)
# Init monorepo workspaces
npm init -y
npm pkg set workspaces='["server","web"]'

# --- Server (Express + TS + Prisma)
mkdir -p server && cd server
npm init -y
npm i express express-session axios cors zod satori @resvg/resvg-js cookie-parser
npm i -D typescript ts-node-dev @types/node @types/express @types/express-session @types/cookie-parser
npm i -D prisma
npm i @prisma/client
npx prisma init
npx tsc --init
cd ..

# --- Web (Vite React + TS)
npm create vite@latest web -- --template react-ts
cd web
npm i @tanstack/react-query framer-motion classnames
npm i -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
cd ..

# Root scripts
npm pkg set scripts.dev="npm-run-all --parallel dev:*"
npm i -D npm-run-all
npm pkg set scripts.dev:api="npm --prefix server run dev"
npm pkg set scripts.dev:web="npm --prefix web run dev"

4) .env.example (copy values into Replit Secrets)
# Server
PORT=5000
SESSION_SECRET=replace_with_strong_secret
BASE_URL=http://localhost:5000

# Spotify OAuth
SPOTIFY_CLIENT_ID=...
SPOTIFY_CLIENT_SECRET=...
SPOTIFY_REDIRECT_URI=http://localhost:5000/auth/spotify/callback

# Database
DATABASE_URL=postgresql://user:pass@host:port/db

5) Prisma schema (server/prisma/schema.prisma)
generator client { provider = "prisma-client-js" }
datasource db { provider = "postgresql"; url = env("DATABASE_URL") }

model User {
  id           String   @id @default(cuid())
  provider     String   @default("spotify")
  providerId   String   @unique
  displayName  String?
  email        String?  @unique
  avatarUrl    String?
  accessToken  String?
  refreshToken String?
  tokenExpires DateTime?
  createdAt    DateTime @default(now())
  spins        Spin[]
  streak       Streak?
}

model Album {
  id        String   @id        // spotify album id
  provider  String   @default("spotify")
  name      String
  artist    String
  year      Int?
  coverUrl  String?
  genres    String[]
  createdAt DateTime @default(now())
  spins     Spin[]
}

model Spin {
  id         String   @id @default(cuid())
  userId     String
  mode       String   @default("personal")
  seed       String?
  albumId    String
  startedAt  DateTime @default(now())
  listenedAt DateTime?
  shareImage String?
  user       User     @relation(fields: [userId], references: [id])
  album      Album    @relation(fields: [albumId], references: [id])
}

model Streak {
  userId       String  @id
  current      Int     @default(0)
  longest      Int     @default(0)
  lastSpinDate DateTime?
  user         User    @relation(fields: [userId], references: [id])
}


Run:

cd server
npx prisma migrate dev --name init

6) Express bootstrap (server/src/index.ts)
import express from "express";
import session from "express-session";
import cors from "cors";
import cookieParser from "cookie-parser";
import { router as spin } from "./routes/spin";
import { router as spins } from "./routes/spins";
import { router as listened } from "./routes/listened";
import { router as share } from "./routes/share";
import { router as catalog } from "./routes/catalog";
import { authRouter } from "./auth/spotify";

const app = express();
app.use(cors({ origin: ["http://localhost:5173"], credentials: true }));
app.use(express.json());
app.use(cookieParser());
app.use(session({
  secret: process.env.SESSION_SECRET!,
  resave: false,
  saveUninitialized: false,
  cookie: { httpOnly: true, sameSite: "lax", secure: false }
}));

app.use("/auth/spotify", authRouter);
app.use("/api/spin", spin);
app.use("/api/spins", spins);
app.use("/api/listened", listened);
app.use("/api/share", share);
app.use("/api/catalog", catalog);

const port = process.env.PORT || 5000;
app.listen(port, () => console.log(`API on :${port}`));

7) Spotify OAuth (server/src/auth/spotify.ts)
import { Router } from "express";
import axios from "axios";
import { prisma } from "../lib/prisma";

export const authRouter = Router();

const SPOTIFY = {
  AUTH: "https://accounts.spotify.com/authorize",
  TOKEN: "https://accounts.spotify.com/api/token",
  API: "https://api.spotify.com/v1",
};
const clientId = process.env.SPOTIFY_CLIENT_ID!;
const clientSecret = process.env.SPOTIFY_CLIENT_SECRET!;
const redirectUri = process.env.SPOTIFY_REDIRECT_URI!;
const scope = "user-read-email user-library-read";

authRouter.get("/login", (req, res) => {
  const state = Math.random().toString(36).slice(2);
  req.session!.state = state;
  const url = `${SPOTIFY.AUTH}?response_type=code&client_id=${clientId}&scope=${encodeURIComponent(
    scope
  )}&redirect_uri=${encodeURIComponent(redirectUri)}&state=${state}`;
  res.redirect(url);
});

authRouter.get("/callback", async (req, res) => {
  const { code, state } = req.query as { code: string; state: string };
  if (!code || state !== req.session!.state) return res.status(400).send("State mismatch");

  const body = new URLSearchParams({
    grant_type: "authorization_code",
    code,
    redirect_uri: redirectUri,
  });

  const tokenRes = await axios.post(SPOTIFY.TOKEN, body.toString(), {
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      Authorization: "Basic " + Buffer.from(`${clientId}:${clientSecret}`).toString("base64"),
    },
  });

  const { access_token, refresh_token, expires_in } = tokenRes.data;
  // Fetch profile
  const me = await axios.get(`${SPOTIFY.API}/me`, {
    headers: { Authorization: `Bearer ${access_token}` },
  });

  const providerId = me.data.id;
  const user = await prisma.user.upsert({
    where: { providerId },
    create: {
      providerId,
      displayName: me.data.display_name,
      email: me.data.email,
      avatarUrl: me.data.images?.[0]?.url ?? null,
      accessToken: access_token,
      refreshToken: refresh_token,
      tokenExpires: new Date(Date.now() + (expires_in - 60) * 1000),
    },
    update: {
      displayName: me.data.display_name,
      email: me.data.email,
      avatarUrl: me.data.images?.[0]?.url ?? null,
      accessToken: access_token,
      refreshToken: refresh_token,
      tokenExpires: new Date(Date.now() + (expires_in - 60) * 1000),
    },
  });

  req.session!.userId = user.id;
  res.redirect("http://localhost:5173"); // web app
});

export async function getAccessToken(userId: string) {
  const user = await prisma.user.findUnique({ where: { id: userId } });
  if (!user) throw new Error("no_user");
  if (user.tokenExpires && user.tokenExpires.getTime() > Date.now() + 30_000) {
    return user.accessToken!;
  }
  // refresh
  const params = new URLSearchParams({
    grant_type: "refresh_token",
    refresh_token: user.refreshToken!,
  });
  const r = await axios.post(SPOTIFY.TOKEN, params.toString(), {
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      Authorization: "Basic " + Buffer.from(`${clientId}:${clientSecret}`).toString("base64"),
    },
  });
  const { access_token, expires_in } = r.data;
  await prisma.user.update({
    where: { id: userId },
    data: {
      accessToken: access_token,
      tokenExpires: new Date(Date.now() + (expires_in - 60) * 1000),
    },
  });
  return access_token as string;
}


server/src/lib/prisma.ts

import { PrismaClient } from "@prisma/client";
export const prisma = new PrismaClient();


Add session typing server/src/types.d.ts:

import "express-session";
declare module "express-session" {
  interface SessionData {
    userId?: string;
    state?: string;
  }
}

8) Album selection & dedupe (server/src/routes/spin.ts)
import { Router } from "express";
import axios from "axios";
import { prisma } from "../lib/prisma";
import { getAccessToken } from "../auth/spotify";

export const router = Router();

router.post("/", async (req, res) => {
  try {
    const userId = req.session.userId;
    if (!userId) return res.status(401).json({ error: "unauthorized" });

    const token = await getAccessToken(userId);

    // Fetch up to 200 saved albums (paginate 50/req)
    const albums: any[] = [];
    let next = `https://api.spotify.com/v1/me/albums?limit=50`;
    while (next && albums.length < 200) {
      const r = await axios.get(next, { headers: { Authorization: `Bearer ${token}` } });
      albums.push(...r.data.items.map((it: any) => it.album));
      next = r.data.next;
    }
    if (!albums.length) return res.status(400).json({ error: "empty_library" });

    // Avoid albums listened in last 30 days
    const cutoff = new Date(Date.now() - 30 * 24 * 3600 * 1000);
    const recentSpins = await prisma.spin.findMany({
      where: { userId, startedAt: { gte: cutoff } },
      select: { albumId: true },
    });
    const blocked = new Set(recentSpins.map(s => s.albumId));

    const pool = albums.filter(a => !blocked.has(a.id));
    const pickSource = pool.length ? pool : albums; // fallback if small library
    const picked = pickSource[Math.floor(Math.random() * pickSource.length)];

    // Upsert Album
    await prisma.album.upsert({
      where: { id: picked.id },
      create: {
        id: picked.id,
        name: picked.name,
        artist: picked.artists?.map((x: any) => x.name).join(", "),
        year: picked.release_date ? Number(picked.release_date.slice(0,4)) : null,
        coverUrl: picked.images?.[0]?.url ?? null,
        genres: [], // optional enrichment later
      },
      update: {},
    });

    const spin = await prisma.spin.create({
      data: {
        userId,
        mode: "personal",
        albumId: picked.id,
      },
      include: { album: true },
    });

    res.json({
      spinId: spin.id,
      album: {
        id: spin.album.id,
        name: spin.album.name,
        artist: spin.album.artist,
        year: spin.album.year,
        coverUrl: spin.album.coverUrl,
        deepLink: `https://open.spotify.com/album/${spin.album.id}`,
      },
    });
  } catch (e: any) {
    console.error(e);
    res.status(500).json({ error: "spin_failed" });
  }
});

9) Streak logic (server/src/routes/listened.ts)
import { Router } from "express";
import { prisma } from "../lib/prisma";

export const router = Router();

function toYMD(d: Date) {
  return d.toISOString().slice(0,10);
}

router.post("/", async (req, res) => {
  const { spinId } = req.body as { spinId: string };
  const userId = req.session.userId;
  if (!userId) return res.status(401).json({ error: "unauthorized" });

  const spin = await prisma.spin.update({
    where: { id: spinId },
    data: { listenedAt: new Date() },
  });

  // Update streak
  const today = new Date();
  const streak = await prisma.streak.upsert({
    where: { userId },
    create: { userId, current: 1, longest: 1, lastSpinDate: today },
    update: {},
  });

  if (streak.lastSpinDate) {
    const last = new Date(streak.lastSpinDate);
    const days = Math.floor((Date.UTC(today.getFullYear(), today.getMonth(), today.getDate())
      - Date.UTC(last.getFullYear(), last.getMonth(), last.getDate())) / 86400000);

    let current = streak.current;
    if (days === 0) {
      // already counted today — do nothing
    } else if (days === 1) {
      current += 1;
    } else {
      current = 1; // missed a day
    }
    const longest = Math.max(streak.longest, current);
    const updated = await prisma.streak.update({
      where: { userId },
      data: { current, longest, lastSpinDate: today },
    });
    return res.json({ ok: true, streak: { current: updated.current, longest: updated.longest } });
  } else {
    const updated = await prisma.streak.update({
      where: { userId },
      data: { current: 1, longest: Math.max(streak.longest, 1), lastSpinDate: today },
    });
    return res.json({ ok: true, streak: { current: updated.current, longest: updated.longest } });
  }
});

10) Spin fetch (server/src/routes/spins.ts)
import { Router } from "express";
import { prisma } from "../lib/prisma";

export const router = Router();

router.get("/:id", async (req, res) => {
  const spin = await prisma.spin.findUnique({
    where: { id: req.params.id },
    include: { album: true },
  });
  if (!spin) return res.status(404).json({ error: "not_found" });
  res.json({
    mode: spin.mode,
    startedAt: spin.startedAt,
    album: {
      id: spin.album.id,
      name: spin.album.name,
      artist: spin.album.artist,
      year: spin.album.year,
      coverUrl: spin.album.coverUrl,
      deepLink: `https://open.spotify.com/album/${spin.album.id}`,
    },
  });
});

11) Explore (genre/era) (server/src/routes/catalog.ts)
import { Router } from "express";
import axios from "axios";
import { getAccessToken } from "../auth/spotify";

export const router = Router();

router.get("/", async (req, res) => {
  const userId = req.session.userId;
  if (!userId) return res.status(401).json({ error: "unauthorized" });

  const { genre, era } = req.query as { genre?: string; era?: string };
  const token = await getAccessToken(userId);

  // Era -> year range
  const year = (() => {
    if (!era) return "";
    const map: Record<string, string> = {
      "1960s": "1960-1969",
      "1970s": "1970-1979",
      "1980s": "1980-1989",
      "1990s": "1990-1999",
      "2000s": "2000-2009",
      "2010s": "2010-2019",
      "2020s": "2020-2029",
    };
    return map[era] ?? "";
  })();

  // Spotify search — track/artist have better genre tags; we bias album type
  const q = [
    genre ? `genre:"${genre}"` : "",
    year ? `year:${year}` : "",
    "album",
  ].filter(Boolean).join(" ");

  const url = `https://api.spotify.com/v1/search?q=${encodeURIComponent(q)}&type=album&limit=50`;
  const r = await axios.get(url, { headers: { Authorization: `Bearer ${token}` } });
  const items = r.data.albums?.items ?? [];
  if (!items.length) return res.status(404).json({ error: "no_results" });

  const picked = items[Math.floor(Math.random() * items.length)];
  res.json({
    album: {
      id: picked.id,
      name: picked.name,
      artist: picked.artists?.map((x: any) => x.name).join(", "),
      year: picked.release_date ? Number(picked.release_date.slice(0,4)) : null,
      coverUrl: picked.images?.[0]?.url ?? null,
      deepLink: `https://open.spotify.com/album/${picked.id}`,
    },
  });
});

12) Share image (server/src/routes/share.ts)
import { Router } from "express";
import satori from "satori";
import { Resvg } from "@resvg/resvg-js";
import { prisma } from "../lib/prisma";

export const router = Router();

router.post("/", async (req, res) => {
  const { spinId } = req.body as { spinId: string };
  const spin = await prisma.spin.findUnique({
    where: { id: spinId },
    include: { album: true, user: true },
  });
  if (!spin) return res.status(404).json({ error: "not_found" });

  const svg = await satori(
    {
      type: "div",
      props: {
        style: {
          width: 1080, height: 1920, display: "flex", flexDirection: "column",
          alignItems: "center", justifyContent: "center", background: "#F6EEDB"
        },
        children: [
          { type: "div", props: { style: { fontSize: 64, marginBottom: 24 }, children: "RekordRoulette" } },
          { type: "div",
            props: {
              style: {
                width: 880, height: 880, borderRadius: 440, position: "relative",
                background: "#3B2B2A"
              },
              children: [
                { type: "img", props: { src: spin.album.coverUrl ?? "", width: 720, height: 720,
                  style: { position: "absolute", left: 80, top: 80, borderRadius: 16 } } },
                { type: "div", props: { style: {
                    position: "absolute", top: 0, left: 440, width: 6, height: 120, background: "#C73B2F"
                }}}
              ]
            }
          },
          { type: "div", props: { style: { fontSize: 42, marginTop: 32 },
            children: `I spun ${spin.album.name} by ${spin.album.artist}` } },
        ],
      }
    },
    { width: 1080, height: 1920, fonts: [] }
  );

  const png = new Resvg(Buffer.from(svg)).render().asPng();
  res.setHeader("Content-Type", "image/png");
  res.send(png);
});

13) React: Spinner + pages (essentials)

web/tailwind.config.js → include ./index.html, ./src/**/*.{ts,tsx} and add a warm palette if you like.

web/src/components/Spinner.tsx

import { motion } from "framer-motion";

export default function Spinner({ spinning }: { spinning: boolean }) {
  return (
    <div className="relative mx-auto h-64 w-64 rounded-full border-8 border-stone-800 bg-stone-800">
      <motion.div
        animate={{ rotate: spinning ? 1080 : 0 }}
        transition={{ duration: 2, ease: [0.2, 0.8, 0.2, 1] }}
        className="absolute inset-4 rounded-full border-4 border-orange-600"
      />
      <div className="absolute left-1/2 top-0 h-8 w-2 -translate-x-1/2 rounded-b bg-red-600" />
    </div>
  );
}


web/src/pages/Landing.tsx

import { useMutation } from "@tanstack/react-query";
import Spinner from "../components/Spinner";
import { useState } from "react";

export default function Landing() {
  const [spinning, setSpinning] = useState(false);
  const spinMutation = useMutation({
    mutationFn: async () => {
      const r = await fetch("http://localhost:5000/api/spin", {
        method: "POST",
        credentials: "include",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ mode: "personal" }),
      });
      if (!r.ok) throw new Error("spin_failed");
      return r.json();
    },
    onSuccess: (data) => {
      setTimeout(() => {
        window.location.href = `/spin/${data.spinId}`;
      }, 1800);
    }
  });

  return (
    <main className="flex min-h-screen flex-col items-center justify-center gap-6 p-6 text-center">
      <h1 className="text-4xl font-extrabold">RekordRoulette</h1>
      <Spinner spinning={spinning || spinMutation.isPending} />
      <div className="flex gap-3">
        <a href="http://localhost:5000/auth/spotify/login"
           className="rounded bg-stone-900 px-4 py-2 text-white">Connect Spotify</a>
        <button
          onClick={() => { setSpinning(true); spinMutation.mutate(); }}
          className="rounded bg-orange-600 px-4 py-2 text-white disabled:opacity-60"
          disabled={spinMutation.isPending}
        >
          Spin Your Album of the Day
        </button>
      </div>
      {spinMutation.isError && <p className="text-red-600">Spin failed. Connect Spotify first.</p>}
    </main>
  );
}


web/src/pages/SpinReveal.tsx

import { useEffect, useState } from "react";

export default function SpinReveal() {
  const spinId = window.location.pathname.split("/").pop();
  const [data, setData] = useState<any>(null);

  useEffect(() => {
    (async () => {
      const r = await fetch(`http://localhost:5000/api/spins/${spinId}`, { credentials: "include" });
      setData(await r.json());
    })();
  }, [spinId]);

  if (!data) return <div className="p-6">Loading…</div>;
  const a = data.album;

  async function markListened() {
    await fetch("http://localhost:5000/api/listened", {
      method: "POST",
      credentials: "include",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ spinId }),
    });
    alert("Marked as listened");
  }

  async function share() {
    const r = await fetch("http://localhost:5000/api/share", {
      method: "POST",
      credentials: "include",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ spinId }),
    });
    const blob = await r.blob();
    const url = URL.createObjectURL(blob);
    const aEl = document.createElement("a");
    aEl.href = url; aEl.download = "rekordroulette-share.png"; aEl.click();
    URL.revokeObjectURL(url);
  }

  return (
    <main className="mx-auto max-w-xl p-6 text-center">
      <img src={a.coverUrl} alt={a.name} className="mx-auto mb-4 w-80 rounded-lg shadow" />
      <h2 className="text-2xl font-semibold">{a.name}</h2>
      <p className="opacity-80">{a.artist} • {a.year ?? "—"}</p>
      <div className="mt-4 flex justify-center gap-3">
        <a className="rounded bg-green-700 px-4 py-2 text-white" href={a.deepLink} target="_blank">Play in Spotify</a>
        <button className="rounded bg-orange-600 px-4 py-2 text-white" onClick={markListened}>Mark as listened</button>
        <button className="rounded border px-4 py-2" onClick={share}>Share</button>
      </div>
    </main>
  );
}


web/src/App.tsx

import { BrowserRouter, Routes, Route } from "react-router-dom";
import Landing from "./pages/Landing";
import SpinReveal from "./pages/SpinReveal";

export default function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Landing />} />
        <Route path="/spin/:id" element={<SpinReveal />} />
      </Routes>
    </BrowserRouter>
  );
}


web/src/main.tsx

import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./styles.css";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

const qc = new QueryClient();
ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <QueryClientProvider client={qc}>
      <App />
    </QueryClientProvider>
  </React.StrictMode>
);

What next?

Wire a simple Profile page (GET /me route if you want) to show current/longest streak and recent spins.

Add CORS origins and set production URLs on Replit.

When you’re ready: add Daily Challenge and a nicer share template (I can drop the Satori JSX for a roulette/vinyl frame when you want it prettier).